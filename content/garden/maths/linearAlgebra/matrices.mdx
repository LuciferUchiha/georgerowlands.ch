import Callout from '@components/Callout/Callout';
import Image from "@components/Image/Image";

# Matrices

You can think of a matrix as rectangle of objects arranged in rows and columns, like a chessboard. For computer scientist you can also imagine a matrix as a 2D array. A matrix with $m$ rows and $n$ columns is called an $m \times n$ matrix. The number of rows and columns therefore define the size or dimensions of a matrix. The objects in a matrix are commonly referred to as elements or entries. A matrix containing only real numbered elements is called a real matrix and can be defined as follows:

```math
\mathbf{A} \in \mathbb{R}^{m \times n} = \begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix}
```

The elements of a matrix are indexed by their row and then there column. So $a_{ij}$ or sometimes also $(\mathbf{A})_{ij}$ is the element in the $i$th row and $j$th column. This means that a matrix can also be defined as $\mathbf{A} = [a_{ij}]_{1 \leq i \leq m, 1 \leq j \leq n}$.

<Callout type="example">
    ```math 
    \begin{align*}
    \mathbf{A} = \begin{bmatrix}1 & 2 & 3 \\ 4 & 5 & 6 \end{bmatrix} \\
    \mathbf{B} = \begin{bmatrix}1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{bmatrix}
    \end{align*}
    ```
</Callout>

<Callout type="warning">
    The number of rows and columns of a matrix are always written in the order of rows first and columns second! So a matrix with 2 rows and 3 columns is written 
    as a $2 \times 3$ matrix, not a $3 \times 2$ matrix, so $\mathbf{A} \in \mathbb{R}^{2 \times 3}$.
</Callout>

A matrix with only one row is called a row vector or [n-tuple](/garden/maths/calculus/sequencesAndSeries/sequences#n-tuple) and a matrix with only one column is called a column vector. When talking about vectors we usually refer to column vectors. A matrix that only has one row and one column can be thought of as a normal number and is called a scalar and therefore we omit the matrix brackets. To differentiate between the three types of matrices we usually use bold capital letters for matrices, bold lower case letters for column vectors and normal lower case letters for scalars.

<Callout type="example">
    A column vector, i.e. ur usual vector, can be written as follows:

    ```math
    \mathbf{v} \in \mathbb{R}^{n \times 1} = \begin{bmatrix}v_1 \\ v_2 \\ \vdots \\ v_n \end{bmatrix}
    ```

    A row vector can be written as follows:

    ```math
    \mathbf{v} \in \mathbb{R}^{1 \times n} = \begin{bmatrix}v_1 & v_2 & \cdots & v_n \end{bmatrix}
    ```

    A scalar can be written as follows:

    ```math
    \mathbf{v} \in \mathbb{R}^{1 \times 1} = \begin{bmatrix}v \end{bmatrix} = v
    ```
</Callout>


#### Outer Product

We can actually construct a matrix from two vectors. This is called the outer product of two vectors. The outer product is different from the dot product which results in a scalar. Where the dot product is multiply a row vector with a column vector, the outer product is multiplying a column vector with a row vector. The result of the outer product is a matrix where each element is the product of the corresponding elements in the two vectors.

So if we have two vectors $\mathbf{x} \in \mathbb{R}^{m \times 1}$ and $\mathbf{y} \in \mathbb{R}^{n \times 1}$, then we can multiply them together as follows to get a matrix $\mathbf{A} \in \mathbb{R}^{m \times n}$. The outer product can be denoted as a matrix multiplication or as with the symbol $\otimes$.

```math
\mathbf{A} = \mathbf{x}\mathbf{y}^T = \mathbf{x} \otimes \mathbf{y} = \begin{bmatrix}
    x_1 \\
    x_2 \\
    \vdots \\
    x_m
\end{bmatrix} \begin{bmatrix}
    y_1 & y_2 & \dots & y_n
\end{bmatrix} = \begin{bmatrix}
    x_1y_1 & x_1y_2 & \dots & x_1y_n \\
    x_2y_1 & x_2y_2 & \dots & x_2y_n \\
    \vdots & \vdots & \ddots & \vdots \\
    x_my_1 & x_my_2 & \dots & x_my_n
\end{bmatrix}
```

Or more formally:

```math
(\mathbf{A})_{ij} = (\mathbf{x}\mathbf{y}^T)_{ij} = (\mathbf{x} \otimes \mathbf{y})_{ij} = x_iy_j
```

From above we can see that the outer product of two vectors results in a matrix where the columns are the first vector scaled by the components of the second vector and the rows are the second vector scaled by the components of the first vector. So the matrix forms a dependent set of vectors, i.e. the columns/rows of the matrix are linearly dependent. Because the size of largest set of linearly independent vectors is 1, the rank of the matrix is 1.

<Callout type="example">
```math
\begin{bmatrix}
    1 \\
    2 \\
    3
\end{bmatrix} \begin{bmatrix}
    4 & 5 & 6
\end{bmatrix} = \begin{bmatrix}
    1 \cdot 4 & 1 \cdot 5 & 1 \cdot 6 \\
    2 \cdot 4 & 2 \cdot 5 & 2 \cdot 6 \\
    3 \cdot 4 & 3 \cdot 5 & 3 \cdot 6
\end{bmatrix} = \begin{bmatrix}
    4 & 5 & 6 \\
    8 & 10 & 12 \\
    12 & 15 & 18
\end{bmatrix}
```
</Callout>

## Square Matrix

As you can imagine a square matrix is a matrix where the number of rows and columns are equal. The number of rows or columns $n$ is referred to as the order of the square matrix. So a square matrix of order $n$ is an $n \times n$ matrix, i.e. $\mathbf{A} \in \mathbb{R}^{n \times n}$. Square matrices have a number of useful properties and are therefore often used in many different applications.

```math
\mathbf{A} \in \mathbb{R}^{n \times n} =
\begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{n1} & a_{n2} & \cdots & a_{nn}
\end{bmatrix}
```

<Callout type="example">
```math
\mathbf{A} =
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
```
</Callout>

## Null/Zero Matrix

If a matrix only contains elements that are zero it is called a zero or null matrix. A null matrix is denoted as $\mathbf{O}$ as the dimensions are usually implied by the context. If you want to be explicit you can also write $\mathbf{O}_{m \times n}$ where $m$ is the number of rows and $n$ is the number of columns.

```math
\mathbf{O} = \begin{bmatrix}
0 & 0 & 0 \\
0 & 0 & 0 \\
0 & 0 & 0
\end{bmatrix}
```

If the matrix is a column vector we usually use the lower case letter $\mathbf{o}$ to denote a null or zero vector.

```math
\mathbf{o} = \begin{bmatrix}
0 \\ 0 \\ 0
\end{bmatrix}  
```

## Diagonal Matrix

A diagonal matrix is a square matrix where all the elements that are not on the main diagonal are zero. The main diagonal is the diagonal that goes from the top left to the bottom right of the matrix, in other words where the row and column index are equal, i.e. $a_{ij}$ where $i = j$.

So a diagonal matrix is where $a_{ij} = 0$ for all $i \neq j$ and $\mathbf{A} \in \mathbb{R}^{n \times n}$. If a diagonal matrix is defined by the following elements $d_{11}, d_{22}, \ldots, d_{nn}$ then the matrix can be written as:

```math
\mathbf{D} = \text{diag}(d_{11}, d_{22}, \ldots, d_{nn}) = \begin{bmatrix}
d_{11} & 0 & \cdots & 0 \\
0 & d_{22} & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \cdots & d_{nn}
\end{bmatrix}
```

<Callout type="example">
```math
\mathbf{D} = 
\begin{bmatrix}
1 & 0 & 0 \\
0 & 2 & 0 \\
0 & 0 & 3
\end{bmatrix} = \text{diag}(1, 2, 3)
```
</Callout>

The definition of a diagonal matrix can also be extended to non-square matrices. In this case the matrix is still a diagonal matrix if all the elements that are not on the main diagonal are zero.

<Callout type="example">
The following non-square matrix are still diagonal matrices:

```math
\mathbf{D}_1 =
\begin{bmatrix}
1 & 0 & 0 \\
0 & 4 & 0 \\
0 & 0 & -3 \\
0 & 0 & 0
\end{bmatrix} \text{ and } \mathbf{D}_2 =
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 \\
0 & 4 & 0 & 0 & 0 \\
0 & 0 & -3 & 0 & 0
\end{bmatrix}
```
</Callout>

## Identity Matrix

An identity matrix sometimes also called unit matrix or identity of order $n$ is a square diagonal matrix where all the diagonal elements are equal to $1$. The identity matrix is often denoted as $\mathbf{I}$ or $\mathbf{I}_n$ where $n$ is the number of rows and columns in the matrix.

<Callout type="example">
```math
\mathbf{I_3} = \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix} = \text{diag}(1, 1, 1)
```
</Callout>

## Triangular Matrix

A triangular matrix is a square matrix where all the elements above or below the main diagonal are $0$. If all the elements above the diagonal are $0$ it is called a **lower triangular matrix** becuase it only has elements below the diagonal that are non-zero:

```math
(\mathbf{L})_{ij} = 0 \text{ for all } i < j
```

If all the elements below the diagonal are $0$ it is called a **upper triangular matrix** because it only has elements above the diagonal that are non-zero:

```math
(\mathbf{U})_{ij} = 0 \text{ for all } i > j
```

<Callout type="example">
A lower triangular matrix $\mathbf{L}$:

```math
\mathbf{L} =
\begin{bmatrix}
1 & 0 & 0 \\
2 & 3 & 0 \\
4 & 5 & 6
\end{bmatrix}
```

An upper triangular matrix $\mathbf{U}$:

```math
\mathbf{U} =
\begin{bmatrix}
1 & 2 & 3 \\
0 & 4 & 5 \\
0 & 0 & 6
\end{bmatrix}
```
</Callout>

## Matrix Operations

### Matrix Addition

Two matrices can be added together if they have the same dimensions, i.e. $\mathbf{A} \in \mathbb{R}^{m \times n}$ and $\mathbf{B} \in \mathbb{R}^{m \times n}$. The addition of two matrices is defined as the element-wise addition of the matrices:

```math
\mathbf{A} + \mathbf{B} = \begin{bmatrix}
a_{11} + b_{11} & a_{12} + b_{12} & \cdots & a_{1n} + b_{1n} \\
a_{21} + b_{21} & a_{22} + b_{22} & \cdots & a_{2n} + b_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} + b_{m1} & a_{m2} + b_{m2} & \cdots & a_{mn} + b_{mn}
\end{bmatrix}
```

Or more formally:

```math
\mathbf{A} + \mathbf{B} = (\mathbf{A} + \mathbf{B})_{ij} = (\mathbf{A})_{ij} + (\mathbf{B})_{ij}
```

<Callout type="example">
```math
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix} + \begin{bmatrix}
7 & 8 & 9 \\
10 & 11 & 12
\end{bmatrix} = \begin{bmatrix}
8 & 10 & 12 \\
14 & 16 & 18
\end{bmatrix}
```
</Callout>

#### Additive Identity

As you can expect the addition of any matrix with the null matrix results in the original matrix:

```math
\mathbf{A} + \mathbf{O} = \mathbf{A}
```

#### Additive Inverse

We can also expect to find a matrix $\mathbf{B}$ that when added to $\mathbf{A}$ results in the null matrix:

```math
\mathbf{A} + \mathbf{B} = \mathbf{O}
```

The matrix $\mathbf{B}$ is called the additive inverse of $\mathbf{A}$ and is denoted as $-\mathbf{A}$ where each element in the matrix is defined as the negative of the corresponding element in the matrix $\mathbf{A}$:

```math
(-\mathbf{A})_{ij} = -(\mathbf{A})_{ij}
```

By using the additive inverse we can also subtract two matrices. The subtraction of two matrices is defined as the addition of the first matrix and the additive inverse of the second matrix:

```math
\mathbf{A} - \mathbf{B} = \mathbf{A} + (-\mathbf{B})
```

<Callout type="example">
```math
\mathbf{A} - \mathbf{B} = \begin{bmatrix}
7 & 8 & 9 \\
10 & 11 & 12
\end{bmatrix} - \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix} = \begin{bmatrix}
7 - 1 & 8 - 2 & 9 - 3 \\
10 - 4 & 11 - 5 & 12 - 6
\end{bmatrix} = \begin{bmatrix}
6 & 6 & 6 \\
6 & 6 & 6
\end{bmatrix}
```
</Callout>

### Scalar Multiplication

A matrix can be multiplied by a scalar, i.e. a constant. This is defined as the element-wise multiplication of the matrix with the scalar:

```math
s \cdot \mathbf{A} = \begin{bmatrix}
s \cdot a_{11} & s \cdot a_{12} & \cdots & s \cdot a_{1n} \\
s \cdot a_{21} & s \cdot a_{22} & \cdots & s \cdot a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
s \cdot a_{m1} & s \cdot a_{m2} & \cdots & s \cdot a_{mn}
\end{bmatrix}
```

Or more formally:

```math
s \cdot \mathbf{A} = (s \cdot \mathbf{A})_{ij} = s \cdot (\mathbf{A})_{ij}
```

<Callout type="example">
```math
5 \cdot \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix} = \begin{bmatrix}
5 \cdot 1 & 5 \cdot 2 & 5 \cdot 3 \\
5 \cdot 4 & 5 \cdot 5 & 5 \cdot 6
\end{bmatrix} = \begin{bmatrix}
5 & 10 & 15 \\
20 & 25 & 30
\end{bmatrix}
```
</Callout>

### Matrix Multiplication

Matrix multiplication is a bit more complex than addition and scalar multiplication. One would think that multiplying two matrices together would be as simple as multiplying each element of the first matrix with the corresponding element in the second matrix and would therefore just like addition be an element-wise operation and only defined for matrices with the same dimensions. However, this is not the case, this would be the [Hadamard product](/garden/maths/linearAlgebra/hadamardProduct) of two matrices. The reason for a more complex definition is due to relationship that the matrix multiplication has with linear transformations to which we will come later.

Matrix multiplication is only defined for matrices where the number of columns in the first matrix is equal to the number of rows in the second matrix. We will see why this is the case later. The result of multiplying two matrices together is a new matrix where the number of rows is equal to the number of rows in the first matrix and the number of columns is equal to the number of columns in the second matrix. So the dimensions in a matrix multiplication are defined as follows: 

```math
\mathbf{A} \in \mathbb{R}^{\color{red}{m} \times \color{blue}{n}} \text{ and } \mathbf{B} \in \mathbb{R}^{\color{blue}{n} \times \color{green}{p}} \Rightarrow \mathbf{C} = \mathbf{A} \cdot \mathbf{B} \in \mathbb{R}^{\color{red}{m} \times \color{green}{p}}
```

<Image src="/maths/matrixMultiplicationDimensions.png"
       caption="Dimensions of a matrix multiplication visualized."
       width={300}
/>

The actual calculation of the elements in the resulting matrix is a bit more complex. The element in the $i$-th row and $j$-th column in the resulting matrix is defined as the sum of the products of the elements in the $i$-th row of the first matrix and the $j$-th column of the second matrix. So the element $c_{ij}$ in the resulting matrix is calculated as follows:

```math
c_{ij} = a_{i1} \cdot b_{1j} + a_{i2} \cdot b_{2j} + \cdots + a_{im} \cdot b_{mj} = \sum_{k=1}^m a_{ik} \cdot b_{kj}
```

or more formally:

```math
\mathbf{C} =
\mathbf{A} \cdot \mathbf{B} = (\mathbf{A} \cdot \mathbf{B})_{ij} = \sum_{k=1}^m (\mathbf{A})_{ik} \cdot (\mathbf{B})_{kj} 
= \sum_{k=1}^m a_{ik} \cdot b_{kj}
```

There are three different ways to think about matrix multiplication, the element view, the row view and the column view. The first way would be to think of how a single element in the resulting matrix is calculated. A single element in row $i$ and column $j$ is calculated as the sum of the products of the elements in the $i$-th row of the first matrix and the $j$-th column of the second matrix. Later on you will see that this is the dot product of the $i$-th row and the $j$-th column as vectors. 

<Image src="/maths/matrixMultiplicationElement.png"
       caption="Element-wise view of matrix multiplication."
       width={700}
/>

<Callout type="example">
```math
\begin{align*}
\begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix} \begin{bmatrix}
a & b \\
c & d
\end{bmatrix} &= \begin{bmatrix}
1a + 2c & \quad\quad \\
\quad\quad & \quad\quad \\
\end{bmatrix} \\ 
&= \begin{bmatrix}
1a + 2c & 1b + 2d \\
3a + 4c & 3b + 4d
\end{bmatrix}
\end{align*}
```
</Callout>

The second way to think about matrix multiplication is to see how a column in the resulting matrix is calculated. The first column in the resulting matrix corresponds to the linear combination of the columns in the left matrix where the weights are the elements in the first column of the right matrix. This pattern carries on for the other columns in the resulting matrix.    

<Image src="/maths/matrixMultiplicationColumn.png"
       caption="Column-wise view of matrix multiplication."
       width={700}
/>

<Callout type="example">
```math
\begin{align*}
\begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix} \begin{bmatrix}
a & b \\
c & d
\end{bmatrix} &= \begin{bmatrix}
a \begin{bmatrix} 1 \\ 3 \end{bmatrix} + b \begin{bmatrix} 2 \\ 4 \end{bmatrix} & \quad\quad\quad\quad\quad \\
\end{bmatrix} \\
&= \begin{bmatrix}
a \begin{bmatrix} 1 \\ 3 \end{bmatrix} + b \begin{bmatrix} 2 \\ 4 \end{bmatrix} & c \begin{bmatrix} 1 \\ 3 \end{bmatrix} + d \begin{bmatrix} 2 \\ 4 \end{bmatrix}
\end{bmatrix} = \begin{bmatrix}
1a + 2b & 1c + 2d \\
3a + 4b & 3c + 4d
\end{bmatrix}
\end{align*}
```
</Callout>

The third way to think about matrix multiplication is to see how a row in the resulting matrix is calculated. The first row in the resulting matrix corresponds to the linear combination of the rows in the right matrix where the weights are the elements in the first row of the left matrix. This pattern carries on for the other rows in the resulting matrix.

<Image src="/maths/matrixMultiplicationRow.png"
       caption="Row-wise view of matrix multiplication."
       width={700}
/>

<Callout type="example">
```math
\begin{align*}
\begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix} \begin{bmatrix}
a & b \\
c & d
\end{bmatrix} &= \begin{bmatrix}
1 \begin{bmatrix} a & b \end{bmatrix} + 2 \begin{bmatrix} c & d \end{bmatrix} \\
\quad\quad\quad\quad\quad \end{bmatrix} \\
&= \begin{bmatrix}
1 \begin{bmatrix} a & b \end{bmatrix} + 2 \begin{bmatrix} c & d \end{bmatrix} \\
3 \begin{bmatrix} a & b \end{bmatrix} + 4 \begin{bmatrix} c & d \end{bmatrix}
\end{bmatrix} = \begin{bmatrix}
1a + 2c & 1b + 2d \\
3a + 4c & 3b + 4d
\end{bmatrix}
\end{align*}
```
</Callout>

A fourth view of matrix multiplication is that it is the sum of the outer products of the columns of the first matrix and the rows of the second matrix. So you can interpret each outer product as a layer of the resulting matrix. This in turn shows that any matrix can be written as a sum of rank 1 matrices.

<Image
    src="/maths/matrixMultiplicationLayer.png"
    caption="Matrix multiplication as the sum of the outer products of the columns of the first matrix and the rows of the second matrix."
    width={600}
    />

<Callout type="example">
The matrix multiplication of two matrices $\mathbf{A}$ and $\mathbf{B}$ can be written as the sum of the outer products of the columns of $\mathbf{A}$ and the rows of $\mathbf{B}$.

```math
\begin{align*}
\begin{bmatrix}
    1 & 2 \\
    3 & 4
\end{bmatrix} \begin{bmatrix}
    a & b \\
    c & d
\end{bmatrix} &= \begin{bmatrix}
    1 \\
    3
\end{bmatrix} \begin{bmatrix}
    a & b
\end{bmatrix} + \begin{bmatrix}
    2 \\
    4
\end{bmatrix} \begin{bmatrix}
    c & d
\end{bmatrix} \\
&= \begin{bmatrix}
    1 \cdot a & 1 \cdot b \\
    3 \cdot a & 3 \cdot b
\end{bmatrix} + \begin{bmatrix}
    2 \cdot c & 2 \cdot d \\
    4 \cdot c & 4 \cdot d
\end{bmatrix} = \begin{bmatrix}
    a + 2c & b + 2d \\
    3a + 4c & 3b + 4d
\end{bmatrix}
\end{align*}
```
</Callout>

#### Commutative Property

Matrix multiplication is not commutative so:

```math
\mathbf{A} \cdot \mathbf{B} \neq \mathbf{B} \cdot \mathbf{A}
```

This means that the order in which you multiply is important! This already becomes apparent when you look at the dimensions of the matrices. If you multiply a $2 \times 3$ matrix with a $3 \times 2$ matrix you get a $2 \times 2$ matrix. However, if you multiply a $3 \times 2$ matrix with a $2 \times 3$ matrix you get a $3 \times 3$ matrix.

<Callout type="example">
```math
\begin{align*}
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix} \cdot \begin{bmatrix}
7 & 8 \\
9 & 10 \\
11 & 12
\end{bmatrix} &= \begin{bmatrix}
58 & 64 \\
139 & 154
\end{bmatrix} \\
\begin{bmatrix}
7 & 8 \\
9 & 10 \\
11 & 12
\end{bmatrix} \cdot \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix} &= \begin{bmatrix}
39 & 54 & 69 \\
49 & 68 & 87 \\
59 & 82 & 105
\end{bmatrix}
\end{align*}
```

Even if the dimensions of the matrices are the same the result of the matrix multiplication can be different depending on the order of the matrices. 

```math
\begin{align*}
\begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix} \cdot \begin{bmatrix}
5 & 6 \\
7 & 8
\end{bmatrix} &= \begin{bmatrix}
19 & 22 \\
43 & 50
\end{bmatrix} \\
\begin{bmatrix}
5 & 6 \\
7 & 8
\end{bmatrix} \cdot \begin{bmatrix}
1 & 2 \\
3 & 4
\end{bmatrix} &= \begin{bmatrix}
23 & 34 \\
31 & 46
\end{bmatrix}
\end{align*}
```

For the element $c_{11}$ we can clearly see why the order of the matrices is important:

```math
\begin{align*}
c_{11} &= 1 \cdot 5 + 2 \cdot 7 = 19 \\
c_{11} &= 5 \cdot 1 + 6 \cdot 3 = 23 \\
19 &\neq 23
\end{align*}
```
</Callout>

There are however some special matrices that are commutative to each other. These matrices are called **commutative matrices** or **commute** to each other so:

```math
\mathbf{A} \cdot \mathbf{B} = \mathbf{B} \cdot \mathbf{A}
```

<Callout type="example">
For the three matrices $\mathbf{A}$, $\mathbf{B}$ and $\mathbf{C}$:

```math
\mathbf{A} = \begin{bmatrix}
2 & 6 \\
1 & 7
\end{bmatrix} \quad \mathbf{B} = \begin{bmatrix}
-3 & -1 \\
2 & 1
\end{bmatrix} \quad \mathbf{C} = \begin{bmatrix}
15 & 6 \\
1 & 20
\end{bmatrix}
```

We can calculate the following:

```math
\begin{align*}
\mathbf{AB} = \begin{bmatrix}
6 & 4 \\
11 & 6
\end{bmatrix} \quad \mathbf{BA} = \begin{bmatrix}
-7 & -25 \\
5 & 19
\end{bmatrix} \\
\mathbf{AC} = \begin{bmatrix}
36 & 132 \\
22 & 146
\end{bmatrix} \quad \mathbf{CA} = \begin{bmatrix}
36 & 132 \\
22 & 146
\end{bmatrix} \\
\end{align*}
```

We can see that the matrices $\mathbf{A}$ and $\mathbf{C}$ commute to each other.

```math
\mathbf{A} \cdot \mathbf{C} = \mathbf{C} \cdot \mathbf{A}
\quad \text{and} \quad
\mathbf{A} \cdot \mathbf{B} \neq \mathbf{B} \cdot \mathbf{A}
```
</Callout>

#### Associative Property

Matrix multiplication is associative so:

```math
(\mathbf{A} \cdot \mathbf{B}) \cdot \mathbf{C} = \mathbf{A} \cdot (\mathbf{B} \cdot \mathbf{C})
```

This mean that the order in which you group the matrices in a multiplication does not matter. However, this does not mean that the order in which you multiply the matrices does not matter. As we have seen before matrix multiplication is not commutative.

The associative property is very useful for linear transformations as it allows you to combine multiple transformations into a single transformation.

<Callout type="proof">
We have the following matrices:

```math
\mathbf{A} \in \mathbb{R}^{m \times n} \quad \mathbf{B} \in \mathbb{R}^{n \times p} \quad \mathbf{C} \in \mathbb{R}^{p \times q}
```

Then we can see that the following two equations become the same:

```math
\begin{align*}
((\mathbf{A}  \mathbf{B}) \mathbf{C})_{ik} &=
\sum_{l=1}^p (\mathbf{A}  \mathbf{B})_{il}  c_{lk} =
\sum_{l=1}^p \sum_{j=1}^n a_{ij} b_{jl}  c_{lk} \\
(\mathbf{A} (\mathbf{B} \mathbf{C}))_{ij} &=
\sum_{j=1}^n a_{ij} (\mathbf{B} \mathbf{C})_{jk} =
\sum_{j=1}^n \sum_{l=1}^p a_{ij} b_{jl}  c_{lk}
\end{align*}
```
</Callout>

#### Distributive Property

The matrix multiplication is left distributive over addition and right distributive over addition so:

```math
\begin{align*}
\mathbf{A} \cdot (\mathbf{B} + \mathbf{C}) = \mathbf{A} \cdot \mathbf{B} + \mathbf{A} \cdot \mathbf{C} \\
(\mathbf{A} + \mathbf{B}) \cdot \mathbf{C} = \mathbf{A} \cdot \mathbf{C} + \mathbf{B} \cdot \mathbf{C}
\end{align*}
```

<Callout type="proof">
For the matrices $\mathbf{A}$, $\mathbf{B}$ and $\mathbf{C}$:

```math
\mathbf{A} \in \mathbb{R}^{m \times n} \quad \mathbf{B} \in \mathbb{R}^{m \times n} \quad \mathbf{C} \in \mathbb{R}^{n \times p}
```
    
Then we can see that the following two equations become the same:

```math
\begin{align*}
((\mathbf{A} + \mathbf{B}) \cdot \mathbf{C})_{ij} &= \sum_{k=1}^n (\mathbf{A} + \mathbf{B})_{ik} c_{kj} \\
&= \sum_{k=1}^n (a_{ik} + b_{ik}) c_{kj} = \sum_{k=1}^n a_{ik} c_{kj} + b_{ik} c_{kj} = \sum_{k=1}^n a_{ik} c_{kj} + \sum_{k=1}^n b_{ik} c_{kj} \\
&= (\mathbf{A} \cdot \mathbf{C})_{ij} + (\mathbf{B} \cdot \mathbf{C})_{ij}
\end{align*}
```
</Callout>

#### Multiplicative Identity

With regards to matrix multiplication the identity matrix is a special matrix. The identity matrix functions as the multiplicative identity or also called the neutral element for matrix multiplication. Meaning that if you multiply any matrix with the identity matrix you get the same matrix back. The identity matrix is also commute to any matrix. 

```math
\mathbf{I} \cdot \mathbf{A} = \mathbf{A} \cdot \mathbf{I} = \mathbf{A}
```

The reason as to why the identity matrix functions as the multiplicative identity can quite easily be seen if you think of the first row in the identity matrix as selecting all the elements in the first row of the second matrix. Then the second row in the identity matrix selects all the elements in the second row of the second matrix and so on. So it can be thought of as the 1 in each row/column of the identity matrix selecting the corresponding row/column in the second matrix.

<Callout type="example">
```math
\mathbf{I} \cdot {A} =
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix} \cdot \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix} = \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
```

The same is true for the other way around:

```math
\mathbf{A} \cdot {I} =
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix} \cdot \begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1
\end{bmatrix} = \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
```
</Callout>

#### Multiply Triangular Matrices

<Callout type="todo">
Show that upper times upper triangular matrices result in an upper triangular matrix and lower times lower triangular matrices result in a lower triangular matrix.

What about upper times lower triangular matrices? What about lower times upper triangular matrices?

What about normal times triangular matrices?
</Callout>

#### Matrix Exponentiation by Squaring

Using exponentiation by squaring you can quickly calculate the power of any number. The idea is to make use of the fact that multiplication is associative so:

```math
a^{10} = a^{5} \cdot a^{5} = (a^{2} \cdot a^{2} \cdot a) \cdot (a^{2} \cdot a^{2} \cdot a)
```

So rather then performing 9 multiplications if we memorize the results we only need to perform the following multiplications:

```math
\begin{align*}
a^{2} &= a \cdot a \\
a^{4} &= a^{2} \cdot a^{2} \\
a^{5} &= a^{4} \cdot a \\
a^{10} &= a^{5} \cdot a^{5}
\end{align*}
```

Which is only 4 multiplications rather then 9. This can be generalized to any power of $k$:

```math
a^k = \begin{cases}
1 & \text{if } k = 0 \\
a & \text{if } k = 1 \\
(a^{\frac{k}{2}}) \cdot (a^{\frac{k}{2}}) & \text{if } k \text{ is even} \\
a \cdot (a^{\frac{k-1}{2}}) \cdot (a^{\frac{k-1}{2}}) & \text{if } k \text{ is odd}
\end{cases}
```

This can also be applied to matrices. The matrix exponentiation by squaring is defined in the same way as for numbers:

```math
\mathbf{A}^k = \begin{cases}
\mathbf{I} & \text{if } k = 0 \\
\mathbf{A} & \text{if } k = 1 \\
(\mathbf{A}^{\frac{k}{2}}) \cdot (\mathbf{A}^{\frac{k}{2}}) & \text{if } k \text{ is even} \\
\mathbf{A} \cdot (\mathbf{A}^{\frac{k-1}{2}}) \cdot (\mathbf{A}^{\frac{k-1}{2}}) & \text{if } k \text{ is odd}
\end{cases}
```

This results in a time complexity of $O(\log k)$ for calculating the power of a matrix. This is much faster than the naive approach which would take $O(k)$ time.

#### Matrix Chain Multiplication

<Callout type="todo">
This is not yet complete and is just a rough scribbling
</Callout>

When you want to multiply multiple matrices the number of multiplications can quickly add up. However, you can use the associative property to group the matrices in a way that you can minimize the number of multiplications. So given some matrices $\mathbf{A}_1, \mathbf{A}_2, \ldots, \mathbf{A}_n$ where the matrix $\mathbf{A}_i$ has dimensions $\mathbb{R}^{m_{i-1} \times m_i}$ we want to find the product of all the matrices with the least amount of multiplications.

Show example with 3 matrices of dimensions $k \times 1$, $1 \times k$ and $k \times 1$. Results in either $O(k)$ or $O(k^2)$ multiplications.

We can write a dynamic programming algorithm to find the optimal way to multiply the matrices. The algorithm is called the **Matrix Chain Multiplication** algorithm. and runs in $O(n^3)$ time which is anyway the time complexity of multiplying one matrix with another matrix.

#### Permutation Matrix

We have seen that the identity matrix is a special matrix that functions as the multiplicative identity for matrix multiplication and can be used to select the corresponding row/column in another matrix. A permutation matrix commonly denoted as $\mathbf{P}$ is a matrix that can be used to permute the rows or columns of another matrix. A permutation matrix is a square matrix where each row and column contains exactly one 1 and all the other elements are 0. Depending on if you want to permute the rows or the columns you can use the permutation matrix as the left or right matrix in the multiplication.

To permute the rows of a matrix you can use the permutation matrix as the left matrix in the multiplication. By swapping the rows of the identity matrix you can permute the rows of the matrix.

<Callout type="example">
We can swap the first and second row of the matrix $\mathbf{A}$:

```math
\mathbf{P} \mathbf{A} = \begin{bmatrix}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1
\end{bmatrix} \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix} = \begin{bmatrix}
4 & 5 & 6 \\
1 & 2 & 3 \\
7 & 8 & 9
\end{bmatrix}
```
</Callout>

To permute the columns of a matrix you can use the permutation matrix as the right matrix in the multiplication. By swapping the columns of the identity matrix you can permute the columns of the matrix.

<Callout type="example">
We can swap the first and second column of the matrix $\mathbf{A}$:

```math
\mathbf{A} \mathbf{P} = \begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix} \begin{bmatrix}
0 & 1 & 0 \\
1 & 0 & 0 \\
0 & 0 & 1
\end{bmatrix} = \begin{bmatrix}
2 & 1 & 3 \\
5 & 4 & 6 \\
8 & 7 & 9
\end{bmatrix}
```
</Callout>

<Callout type="todo">
Permutation and then doing another permuation results in another permutation. This is not yet complete and needs to be written.

The inverse of a permutation matrix is the transpose of the matrix. This kind of makes sense but is not immediately obvious.

Because of this it is also orthogonal
</Callout>

#### Strassen's Algorithm

<Callout type="todo">
This needs to be written. We use $O(n^{\log_2 7}) \approx O(n^{2.81})$ time to multiply two matrices using Strassen's algorithm. This is faster than the naive algorithm which uses $O(n^3)$ time. The algorithm works by reducing the number of arithmetic operations needed to multiply two matrices by breaking them down into smaller subproblems. It does this by recursively dividing the matrices into smaller matrices and combining the results in a clever way.

The reduction in the number of arithmetic operations however comes at the price of a somewhat reduced numerical stability, and the algorithm also requires significantly more memory compared to the naive algorithm. Both initial matrices must have their dimensions expanded to the next power of 2, which results in storing up to four times as many elements, and the seven auxiliary matrices each contain a quarter of the elements in the expanded ones.
</Callout>

#### Winograd's Algorithm

<Callout type="todo">
This needs to be written. further improves this to $O(n^{2.37})$ time?
</Callout>

### Transpose

The transpose of a matrix is a matrix where the rows and columns are swapped. The transpose of the matrix $\mathbf{A}$ is written as $\mathbf{A}^T$. Formally the element in the $i$-th row and $j$-th column in the matrix $\mathbf{A}$ becomes the element in the $j$-th row and $i$-th column in the matrix $\mathbf{A}^T$. 

```math
\mathbf{A} = \begin{bmatrix}
a_{11} & a_{12} & \cdots & a_{1n} \\
a_{21} & a_{22} & \cdots & a_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
a_{m1} & a_{m2} & \cdots & a_{mn}
\end{bmatrix} \Rightarrow \mathbf{A}^T = \begin{bmatrix}
a_{11} & a_{21} & \cdots & a_{m1} \\
a_{12} & a_{22} & \cdots & a_{m2} \\
\vdots & \vdots & \ddots & \vdots \\
a_{1n} & a_{2n} & \cdots & a_{mn}
\end{bmatrix}
```

Or also more formally:

```math
(\mathbf{A}^T)_{ij} = (\mathbf{A})_{ji}
```

This results in the transpose of a row vector being a column vector and the transpose of a column vector being a row vector. The same goes for a matrix where the transpose of a matrix results in a matrix with its dimensions swapped. So the transpose of a $m \times n$ matrix is a $n \times m$ matrix.


<Callout type="example">
    Transposing a matrix:

    ```math
    \mathbf{A} = \begin{bmatrix}
    1 & 2 & 3 \\ 
    4 & 5 & 6 
    \end{bmatrix} \Rightarrow \mathbf{A}^T = \begin{bmatrix}
    1 & 4 \\
    2 & 5 \\
    3 & 6
    \end{bmatrix}
    ```

    Transposing a column vector is very useful when you want to write vectors in a readable way in a text,
    as you can see. Most commonly in textbooks when a vector is defined it is defined as a transposed column vector.

    ```math
    \mathbf{v} = \begin{bmatrix}
    v_1 \\ v_2 \\ \vdots \\ v_n 
    \end{bmatrix} \Rightarrow \mathbf{v}^T = \begin{bmatrix}
    v_1 & v_2 & \cdots & v_n 
    \end{bmatrix}
    ```

    Transposing a row vector: 

    ```math
    \mathbf{v} = \begin{bmatrix}
    v_1 & v_2 & \cdots & v_n 
    \end{bmatrix} \Rightarrow \mathbf{v}^T = \begin{bmatrix}
    v_1 \\ v_2 \\ \vdots \\ v_n 
    \end{bmatrix}
    ```
</Callout>

There are a few useful properties of the transpose of a matrix that are worth remembering. The first it that if a matrix is transposed twice it is the same as the original matrix:

```math
(\mathbf{A}^T)^T = \mathbf{A}
```

<Callout type="example">
```math
\mathbf{A} = \begin{bmatrix} 
1 & 2 & 3 \\ 
4 & 5 & 6 
\end{bmatrix} \Rightarrow \mathbf{A}^T = \begin{bmatrix} 
1 & 4 \\
2 & 5 \\
3 & 6 
\end{bmatrix} \Rightarrow (\mathbf{A}^T)^T = \begin{bmatrix} 
1 & 2 & 3 \\ 
4 & 5 & 6 
\end{bmatrix} = \mathbf{A}
```
</Callout>

Another important property is that when you apply a transpose to some expression in brackets the order of the matrices is reversed. For addition this does not matter as it is commutative but for multiplication it does matter. So:

```math
\begin{align*}
(\mathbf{A} + \mathbf{B})^T &= \mathbf{A}^T + \mathbf{B}^T \\
(\mathbf{A} \cdot \mathbf{B})^T &= \mathbf{B}^T \cdot \mathbf{A}^T
(\mathbf{ABCD})^T &= \mathbf{D}^T \cdot \mathbf{C}^T \cdot \mathbf{B}^T \cdot \mathbf{A}^T
\end{align*}
```

#### Symmetric Matrix

If a matrix is equal to its transpose it is called a symmetric matrix. So $\mathbf{A} = \mathbf{A}^T$ and for each element in the matrix $a_{ij} = a_{ji}$. As you can quite easily imagine a prerequisite for a matrix to be symmetric is that it is a square matrix as otherwise the transpose of the matrix would have different dimensions.

Another thing that makes sense is that a diagonal matrix is always symmetric as all the elements that are not on the diagonal are zero.

<Callout type="example">
A symmetric matrix:

```math
\mathbf{A} = \begin{bmatrix}
1 & 2 & 3 \\
2 & 4 & 5 \\
3 & 5 & 6
\end{bmatrix} \Rightarrow \mathbf{A}^T = \begin{bmatrix}
1 & 2 & 3 \\
2 & 4 & 5 \\
3 & 5 & 6
\end{bmatrix} = \mathbf{A}
```

A diagonal matrix is also symmetric:

```math
\mathbf{A} = \begin{bmatrix}
1 & 0 & 0 \\
0 & 2 & 0 \\
0 & 0 & 3
\end{bmatrix} \Rightarrow \mathbf{A}^T = \begin{bmatrix}
1 & 0 & 0 \\
0 & 2 & 0 \\
0 & 0 & 3
\end{bmatrix} = \mathbf{A}
```
</Callout>

##### Skew-Symmetric Matrix

A skew-symmetric matrix is a matrix where the elements of the matrix are equal to the negative of the elements in the transpose of the matrix. So $\mathbf{A} = -\mathbf{A}^T$ and for each element in the matrix $a_{ij} = -a_{ji}$.

<Callout type="example">
```math
\mathbf{A} = \begin{bmatrix}
0 & 2 & -3 \\
-2 & 0 & 5 \\
3 & -5 & 0
\end{bmatrix} \Rightarrow \mathbf{A}^T = \begin{bmatrix}
0 & -2 & 3 \\
2 & 0 & -5 \\
-3 & 5 & 0
\end{bmatrix} = -\mathbf{A}
```
</Callout>

#### Transposing on a Computer

When you want the transpose of a matrix you don't actually need to perform any operations. You can just change the way you access the elements of the matrix. Rather than accessing the elements row by row you can access them column by column. 

<Image src="/maths/matrixTransposeOnComputers.png"
       caption="Reading a matrix and its transpose."
       width={200}
/>

Depending on the size of the matrix and how many times you need to access the elements of the matrix this can be a lot faster than actually transposing the matrix. However, if you need to access the elements of the matrix multiple times it is probably faster to transpose the matrix first and then access the elements due to memory locality.

To transpose a square matrix in-place you can use the following algorithm which you can think of as swapping the elements of the matrix along the diagonal:

```java
for (int i = 0; i < n; i++) {
    for (int j = i + 1; j < n; j++) {
        swap(A[i][j], A[j][i]);
    }
}
```

For a non-square matrix you need to use a slightly more complex algorithm.

### Inverse

The inverse of a matrix is a very important and special matrix that when multiplied with the original matrix results in the identity matrix. So in other words this special matrix is the multiplicative inverse of the original matrix. The inverse of a matrix is denoted as $\mathbf{A}^{-1}$.

```math
\mathbf{A} \cdot \mathbf{A}^{-1} = \mathbf{A}^{-1} \cdot \mathbf{A} = \mathbf{I}
```

Not all matrices have an inverse. A matrix that has an inverse is called an regular/invertible/non-singular matrix. A matrix that does not have an inverse is called a degenerate/singular/non-invertible matrix. If a matrix is invertible then the inverse is unique, i.e. there is only one inverse for a matrix. For now we will not discuss how to calculate the inverse of a matrix or when a matrix is invertible but we will do so later on in the corresponding sections for [matrix rank](), [determinant]() and [matrix inversion]().

Similarly to the transpose of a matrix the inverse of a matrix has some properties that are worth remembering:

```math
\begin{align*}
(\mathbf{A}^{-1})^{-1} &= \mathbf{A} \\
(\mathbf{A} \cdot \mathbf{B})^{-1} &= \mathbf{B}^{-1} \cdot \mathbf{A}^{-1} \\
(\mathbf{A} + \mathbf{B})^{-1} &\neq \mathbf{A}^{-1} + \mathbf{B}^{-1}
\end{align*}
```

<Callout type="proof">
Let's prove that the inverse of a matrix is unique. We assume we have two inverses $\mathbf{A}^{-1}$ and $\mathbf{B}^{-1}$ for the matrix $\mathbf{A}$. Then we can see that:

```math
\begin{align*}
\mathbf{A} \cdot \mathbf{A}^{-1} &= \mathbf{I} \\
\mathbf{A} \cdot \mathbf{B}^{-1} &= \mathbf{I}
\end{align*}
```

Now we can multiply both sides of the second equation by $\mathbf{A}^{-1}$:

```math
\begin{align*}
\mathbf{A} \cdot \mathbf{B}^{-1} \cdot \mathbf{A}^{-1} &= \mathbf{I} \cdot \mathbf{A}^{-1} \\
\mathbf{B}^{-1} &= \mathbf{A}^{-1}
\end{align*}
```

So we can see that the two inverses are equal and thus the inverse of a matrix is unique.
</Callout>

<Callout type="example">
The following matrix is invertible:

```math
\mathbf{A} = \begin{bmatrix}
1 & 2 & 1 \\
4 & 4 & 5 \\
6 & 7 & 7
\end{bmatrix} \quad \text{with} \quad \mathbf{A}^{-1} = \begin{bmatrix}
-7 & -7 & 6 \\
2 & 1 & -1 \\
4 & 5 & -4
\end{bmatrix}
```

The following simple matrix is not invertible:

```math
\mathbf{A} = \begin{bmatrix}
2 & 4 \\
2 & 4
\end{bmatrix}
```
</Callout>

<Callout type="todo">
    Parts below here are still a work in progress and might not belong here.
</Callout>

### Frobenius Norm

The Frobenius norm is a way to measure the size of a matrix. It is defined as the square root of the sum of the squares of all the elements in the matrix. So for a matrix $\mathbf{A} \in \mathbb{R}^{m \times n}$ the Frobenius norm is defined as follows:

```math
\|\mathbf{A}\|_F = \sqrt{\sum_{i=1}^m \sum_{j=1}^n a_{ij}^2}
```

You can also think of it as just taking the matrix and flattening it into a vector and then calculating the length of that vector, i.e. the Euclidean/L2 norm of the vector.


<Callout type="example">
If we define the matrix $\mathbf{A}$:

```math
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6
\end{bmatrix}
```

Then the Frobenius norm of $\mathbf{A}$ is:

```math
\|\mathbf{A}\|_F = \sqrt{1^2 + 2^2 + 3^2 + 4^2 + 5^2 + 6^2} = \sqrt{91} \approx 9.539
```
</Callout>

### Trace

The trace of a matrix is the sum of all the diagonal elements in the matrix and is denoted as $\text{tr}(\mathbf{A})$. Because it is the sum of the diagonal elements it is only defined for square matrices, i.e. $\mathbf{A} \in \mathbb{R}^{n \times n}$:

```math
\text{tr}(\mathbf{A}) = \sum_{i=1}^n a_{ii} = a_{11} + a_{22} + \cdots + a_{nn}
```

<Callout type="example">
```math
\text{tr}(\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}) = 1 + 5 + 9 = 15
```
</Callout>

<Callout type="todo">
    Add properties of the trace. and proof that it is the sum of the eigenvalues.
</Callout>

## Orthogonal / Orthonormal Matrix

Very unclear what the difference is between these two. I think an orthogonal matrix is a matrix where the columns are orthogonal to each other but don't have to be normalized. And an orthonormal matrix is a matrix where the columns are orthogonal to each other and are normalized, i.e. have a length of $1$.

<Callout type="todo">
    This section is still a work in progress!
</Callout>

## Householder Matrix

## Block Matrix

## Bi- and Tri-Diagonal Matrix

## Band Matrix

## Toeplitz and Hankel Matrix