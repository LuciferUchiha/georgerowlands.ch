import Callout from "../../../../components/callout/callout";

# Arrays and Iterables

## Arrays
Arrays exist in JavaScript just as they do in most other programming languages, however I would describe them to be more like ArrayLists in Java as they don't have a fixed length. The precise details of how arrays are implemented are a bit more complex and depend on the EcmaScript implementation, for further details on how arrays work under the hood in JavaScript I can recommend reading [this article](https://ryanpeden.com/how-do-javascript-arrays-work-under-the-hood/).

```javascript
const cars = ["Saab", "Volvo", "BMW"];
cars = []; // this would not work because const
cars[0] = "Mini"; // this however would work

cars.push("Saab", "Mercedes") // push to the end, array is now longer
console.log(cars.length) // 5
cars.pop() // removes the last element

const person = ["John", "Doe", 46]; // can have values of different types

const numbers = new Array(1,2,3,4,5) // can create array like this but [] literal is preferred
numbers[20] = 21 // has made the array sparase, indexes 4-19 now have the value undefined
```

### Checking for an Array

Checking if a variable holds an array is not as easy as one would expect because the `typeof` operator returns "object". Instead, we have a few solutions:

1. Use the static method `Array.isArray()`.
2. Use the `instanceof` operator.

```javascript
const cars = ["Saab", "Volvo", "BMW"];
console.log(typeof cars); // object
console.log(Array.isArray(cars)); // true
console.log(cars instanceof Array); // true
```

### Sorting

JavaScript arrays can be quietly easily sorted using the `.sort()` method. However, this only really works well for strings as the sort method sorts the array alphabetically using the string representation. But it doesn't work well with other types such as numbers or objects. JavaScript also offers the reverse method which reverses the current order of the array, so if you wanted an array sorted in descending order you could first sort then reverse.

<Callout type="info">
    Important to know is that the sort/reverse method changes the underlying array, it doesn't return a new sorted
    array.
</Callout>

```javascript
const cars = ["Saab", "Volvo", "BMW"];
console.log(cars.sort()); // [BMW', 'Saab', 'Volvo']
console.log(cars); // ['BMW', 'Saab', 'Volvo']

const numbers = [3, 20, 100];
console.log(numbers.sort()); // [100, 20, 3]
console.log(numbers.reverse()); // [3, 20, 100]
```

For objects or numbers or in general if we want more control over how the elements are sorted we can pass an optional function, the so-called compare function. This function takes 2 arguments, `a` and `b`, and compares them ( only if a or b aren't `undefined` as undefined elements are automatically put at the end of the array). If the compare function returns 0 then the 2 elements stay in the same order, if a positive value is returned then `a` is put after `b`, if a negative value is returned then `b` is put after `a`.

```javascript
const numbers = [3, 20, 100];
console.log(numbers.sort()); // [100, 20, 3]
console.log(numbers.sort((a,b) => a - b)); // [3, 20, 100]
```

### Searching and Filtering

If you already know the element you are looking for but wish to know the index, or if the array even contains a certain element the `indexOf()` or `lastIndexOf()` methods can be used which return either the first or the last index of the passed element or if the element was not found the index -1 is returned. An index can also be specified to start the search from.

```javascript
const beasts = ["ant", "bison", "camel", "duck", "bison"];

console.log(beasts.indexOf("bison")); //1
console.log(beasts.indexOf("bison", 2)); // Start from index 2, returns 4
console.log(beasts.lastIndexOf("bison")); // 4
```

<Callout type="info">
    If you only want to know if an array has an element and don't need to know the index you can use the `includes()`
    method.

    ```javascript
    const beasts = ["ant", "bison", "camel", "duck", "bison"];
    console.log(beasts.includes("ant")); // true
    console.log(beasts.indexOf("ant") !== -1); // true
    ```
</Callout>


Instead of looking for an index of a certain element we can also use the `findIndex()` or `findLastIndex()` methods which work very similar but instead of looking for an element are given a predicate function and return the index of the element that matches that criteria first or last.

```javascript
const beasts = ["ant", "bison", "camel", "duck", "bison"];
const firstBIndex = beasts.findIndex(beast => beast.toLowerCase().startsWith("b"));
console.log(firstBIndex); // 1
```

When looking for an element that matches a certain condition you can use the `find()` method which returns the first element that matches it or undefined. If you only want to know if there is an element that matches the condition and don't need the element you can use the `some()` method.

```javascript
const array = [5, 12, 8, 130, 44];
const firstEven = array.find(e => e % 2 == 0);
console.log(firstEven); // 12
console.log(array.some(e => e % 2 == 0)); // true
```

Filtering allows to only work with a subset of an array. The `filter()` method iterates over each element of the array and calls the provided predicate function once for each element. If the provided predicate function returns true for the value it is shallow copied into a new array which is then returned at the end, if it is false then it is not added to the filtered array.

```javascript
const words = ["spray", "limit", "elite", "exuberant", "destruction", "present"];

const longWords = words.filter(word => word.length > 6);
console.log(longWords); // [ 'exuberant', 'destruction', 'present' ]
const evenWords = words.filter((word, index) => index % 2 == 0);
console.log(evenWords); // [ 'spray', 'elite', 'destruction' ]
```

### Shifting

The `shift()` and `unshift()` array methods almost do the same as the `pop` and `push()` methods but in the opposite way. The shift method removes the first element, whereas the pop method removes the last and the unshift method allows you to add elements to the front of an array whereas the push method lets you add to the back of the array.

```javascript
const cars = ["Saab", "Volvo", "BMW"];
console.log(cars.shift()); // ["Volvo", "BMW"]
console.log(cars.unshift("Saab", "Mini")); // ["Saab", "Mini", "Volvo", "BMW"]
```

### Other Methods

reduce, map, slice and splice, join and concat

## Spread Operator

The spread operator `...` allows you to pull elements out of an array (=> split the array into a list of its elements) or pull the properties out of an object. The spread operator copies data safely (i.e. preventing future mutation of the copied original).

```jsx
const oldArray = [1, 2, 3];
const newArray = [...oldArray, 4, 5]; // This now is [1, 2, 3, 4, 5];
const oldObject = {
  name: "Max"
};
const newObject = {
  ...oldObject,
  age: 28
};
```

## Destructuring

Destructuring allows you to easily access and copy (not reference) the values of arrays or objects and assign them to variables.

```jsx
const array = [1, 2, 3];
const [a, b] = array;
console.log(a); // prints 1
console.log(b); // prints 2
const myObj = {
  name: "Max",
  age: 28
}
const {name} = myObj;
console.log(name); // prints "Max"
console.log(age); // prints undefined
console.log(myObj); // prints {name: "Max", age: 28}
```

## Sets and Maps

### Weak Iterables
