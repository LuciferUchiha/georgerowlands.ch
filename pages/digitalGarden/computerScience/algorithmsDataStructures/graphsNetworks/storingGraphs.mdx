# Storing Graphs

Because I am computer scientist I don't just care about using graphs but also about how to store them. There are
multiple ways of storing graphs. Depending on the type of graph and the requirements a certain storage method might
be preferred as it might be more efficient in terms of memory or time complexity.

## Adjacency Matrix

An adjacency matrix is the most common and most simple way of storing graphs. If we have a graph with $n$ vertices, we
create an adjacency matrix with dimensions of $n \times n$. As the name suggests this matrix stores the adjacency of
vertices i.e. the relationship between the vertices, the edges.

### Weighted and Unweighted Graphs

If we have a weighted graph where the weights are integer values we can create the following matrix:

```java
int[][] G = new int[n][n]
```

The weight of the edge from vertex $x$ to vertex $y$ would then be stored at `G[x][y]`.

If there is no edge between 2 vertices then there are multiple ways to indicate this. The simplest way would be to set
the value to 0 (which it already is at initialization) another common approach is to set the weight to `Integer.MAX_VALUE`.

The last possibility but worst in space complexity is to use a `null` value. This is only possible if we use an object array instead of a
primitive array. This would mean that instead of using `int[][]` we use `Integer[][]`. This would however mean that
we would end up using a lot more memory as you can read more about [here](https://stackoverflow.com/a/65568047/10994912)

If the graph is unweighted we can use the same int array and just store all edge weights as 1 or 0. We could however
also use a 2D boolean array which interestingly does use less space in java then a int array. In Java a normal boolean
variable uses 32 bits like an int. However, in an array each boolean value only takes up 8 bits because that is what the
CPU likes to work with internally. This means that a boolean array uses 4 times less space than an int array.

### Directed and Undirected Graphs

If the graph is undirected then we commonly set the value at `G[x][y]` and `G[y][x]` to the same value. This means that
mathematically $G = G^T$ i.e. the matrix is symmetric along the diagonal, and that we could get away with only storing
the upper or lower triangle of the matrix, which would half the memory usage. However, this would make the code more
complicated.

The biggest problem with storing graphs with an adjacency matrix is that $O(n^2)$ memory is used and a lot of the space is wasted as in most cases there are only a few edges between vertices and we don't need to be able to store every possible combination.

![adjacencyMatrix](/compSci/adjacencyMatrix.png)

Adjacency matrices are however very easy to implement:

```java
public class UndirectedUnweightedGraph {
    private final boolean[][] adjMatrix;
    public final int n;

    public GraphI(int numNodes) {
        if (numNodes < 1) throw new IllegalArgumentException();
        this.adjMatrix = new boolean[numNodes][numNodes];
        this.n = numNodes;
    }

    public boolean addEdge(int u, int v) {
        if (0 <= u && u < n && 0 <= v && v < n) {
            if (adjMatrix[u][v]) return false; // already set
            adjMatrix[u][v] = adjMatrix[v][u] = true;
            return true;
        }
        throw new IndexOutOfBoundsException();
    }
}
```

## Edge Table

Another easy but less common way of storing graphs is just storing a list of the edges. The edges could have the following structure:

```java
class Edge {
 int from, to, weight;
}
```

If it is an unweighted graph the weight attribute could just be omitted and if it is an undirected graph you can either have two entries for each edge or handle from and to the same way depending on your implementation.

The advantage of this solution is that it only uses $O(m)$ memory with $m=$ the number of edges. The disadvantage of this storage solution is that you can not quickly find out how many or what vertices are in the graph. This could however be resolved by just adding another list containing all the vertices. This solution would then be very similar to the mathematical description of a graph where $G=(V, E)$ and $V$ is the set of vertices and $E$ is the set containing pairs of vertices for the edges. This would then have a memory usage of $O(n+m)$ with $n$ being the number of vertices and $m$ the number of edges.

## Adjacency List

An adjacency list is very similar to an edge table. Each vertex has an adjacency list of all the edges it has. To then store the entire graph we have a list of adjacency lists. An adjacency list can just be a simple array but it is a linked list due to the storage and length being dynamic. If the graph is undirected you can again either handle it by just storing it in one adjacency list or both adjacency lists. This structure uses just like the edge table $O(n+m)$ memory with $n$ being the number of vertices and $m$ the number of edges.

```java
public class UnweightedGraph<K> {
    private static class Vertex<K> {
        K data;
        int indegree, deg = 0;
        boolean visited;
        List<Vertex<K>> adjList = new LinkedList<Vertex<K>>();

        Vertex(K value) {
            data = value;
        }

        boolean addEdgeTo(Vertex <K> to) {
            return (adjList.contains(to)) ? false : adjList.add(to);
        }
    }

    private Map<K, Vertex<K>> vertices;
    private int nOfEdges = 0;

    public UnweightedGraph() {
        this(false);
    }

    public UnweightedGraph(boolean directed) {
        super(directed);
        vertices = new HashMap<K, Vertex<K>>();
    }

    public UnweightedGraph(UnweightedGraph<K> orig) { // copy constructor
        this(orig.isDirected());
        for (K k: orig.vertices.keySet()) {
            addVertex(k);
        }
        for (Vertex<K> v: orig.vertices.values()) {
            for (Vertex<K> w: v.adjList) {
                addEdge(v.data, w.data);
            }
        }
    }

    public boolean addVertex(K vertex) {
        if (vertex != null && !vertices.containsKey(vertex)) {
            vertices.put(vertex, new Vertex<K>(vertex));
            return true;
        } else {
            return false;
        }
    }

    public boolean addEdge(K from, K to) {
        Vertex<K> vf = vertices.get(from);
        Vertex<K> vt = vertices.get(to);
        if (vf != null && vt != null && vf.addEdgeTo(vt)) {
            vt.indegree++;
            if (!isDirected()) {
                vt.addEdgeTo(vf);
                vf.indegree++;
            }
            nOfEdges++;
            return true;
        } else {
            return false;
        }
    }
}
```
